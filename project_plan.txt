Playfunia MERN Stack Application: Implementation Plan
1. Project Structure and Environment Setup
Repository Layout: Organize the project with clear separation of concerns. At the root, create directories for each major component: frontend/, backend/, chatbot/, docker/, and docs/[1]. Each of these will have its own configuration and dependencies: - Frontend (React + TypeScript): Initialize with Create React App (TypeScript template) or Next.js in TypeScript. This will produce a frontend folder containing the React app (with its own package.json and node_modules separate from the backend[1]). Use a component-based structure (e.g. src/components/, src/pages/, etc.) and include a router (React Router) for navigating pages. - Backend (Node.js + Express + TypeScript): Set up an Express server in the backend folder with TypeScript (use tsc --init to generate a tsconfig.json and use ts-node for development). Maintain a separate package.json here. The backend structure can follow a MVC or layered approach: for example, src/models/ for Mongoose schemas, src/controllers/ for request handlers, src/routes/ for route definitions, and src/middleware/ for auth and other middlewares. Include necessary dependencies: Express for the server, Mongoose for MongoDB ODM, jsonwebtoken (JWT) for auth tokens, bcrypt for password hashing, cors for Cross-Origin Resource Sharing, dotenv for environment config, and Stripe SDK for payment integration (or Square if chosen). All secrets (JWT secret, Stripe API keys, etc.) will be managed via environment variables (with a .env file and a .env.example template for reference). - Chatbot Service (Python FastAPI): Under chatbot/, set up a Python FastAPI application. Use a virtual environment or requirements file for dependencies. Include fastapi and uvicorn (for running the server), openai SDK for calling OpenAI's API, pydantic for data models (request/response validation), httpx or requests for any HTTP calls (e.g., calling backend APIs), and python-dotenv for loading env variables (OpenAI API key, etc.). - Docker and Environment: In the docker/ directory, create a Docker Compose configuration to orchestrate all services. Define services for: - MongoDB: Use the official MongoDB image, exposing the default port 27017. - Backend: Use a Node.js image (like node:18-alpine) to run the Express app on a defined port (e.g. 5000). Mount the source code for dev, and use a multi-stage build for production (compiling TypeScript to JS). Ensure the container links to MongoDB (environment variables for DB host, user, password set via Compose). - Frontend: Use a Node image to build and serve the React app. In development, this could run npm start (port 3000), and in production serve the built static files (e.g. via serve or a simple Node/NGINX server). Ensure it’s accessible (expose port 3000 or 80 as needed). - Chatbot: Use a Python image (e.g. python:3.10-alpine) to run uvicorn for the FastAPI app (expose e.g. port 8000). This service will communicate with the backend (for performing actions) and respond to chatbot queries. - Use Docker Compose networking so that the services can communicate (e.g., backend can be reached by chatbot via http://backend:5000 inside the network). - Environment Variables: Prepare .env.example files for both backend and chatbot, listing required env vars (e.g. MONGO_URL, JWT_SECRET, STRIPE_SECRET_KEY, OPENAI_API_KEY, etc.) and sensible defaults. These will be copied to actual .env in development. In Docker Compose, reference these vars so that each container gets the needed config. - Language & Tools: Use TypeScript throughout the Node and React codebases for type safety. Set strict mode in tsconfig.json. Add helpful dev tools: for backend, use nodemon for auto-reloading on code changes and concurrently (run front and back dev servers together)[2]. Set up ESLint and Prettier for consistent code style in both JS/TS and Python (use flake8/black for Python). - Version Control: Initialize a Git repository and commit the base structure. Include a docs/ directory for documentation (like the provided requirements PDF, design docs, etc.). Add a README describing how to set up and run each part of the project (including Docker usage). - Testing Setup: (Will detail testing later, but early on, install testing libraries: Jest for Node, React Testing Library for front, Pytest for Python.)
2. MongoDB Schema Design
Design robust Mongoose schemas for all core data models, enforcing validation rules and relationships between them. Each schema will be defined in the backend’s src/models/ directory and connected to the MongoDB database.
•	User Model: Represents adult users (parents/guardians). Fields: name, email (unique), passwordHash, phone, address, etc., plus fields for roles (role field or an array if multiple roles; e.g. roles could be "user" or "admin"). The password will be hashed (bcrypt). The User will have relations to other models:
•	One-to-many relation to Child (a user can have multiple children profiles). This can be implemented by storing an array of child ObjectIds in the User (e.g. children: [{ type: ObjectId, ref: "Child" }]) or by storing a parentId in each Child. We will use parent referencing for one-to-many to avoid large arrays[3][4]. Each Child document will have a reference to its parent User.
•	One-to-many to Ticket (tickets purchased by the user), PartyBooking (parties booked by the user), Membership (a user might have at most one active membership, but keep history of memberships), and Waiver (a user might sign multiple waivers over time, but the latest active one is important). These can also be referenced by storing userId in those models.
•	The user schema should include timestamps (createdAt, updatedAt) and any relevant status flags.
•	Child Model: Represents a child of a user. Fields: fullName, birthdate, gender (as provided in waiver), and a reference to the parent User (e.g. parentId: { type: ObjectId, ref: "User", required: true }). This allows querying all children for a user easily. We may not need a separate collection if children are only ever created via waivers; however, having a schema helps if we want to reuse child info (e.g. quick selection of a child when booking a party or checking in).
•	Waiver Model: Stores a signed liability waiver. Fields: userId (ref to User who is the guardian), children (list of child names/birthdates included in the waiver; can store as sub-documents or references to Child IDs if those are created upfront), agreedAt (date/time signed), and flags like agreedToTerms: Boolean and marketingConsent: Boolean. We will securely archive these records for legal accountability for at least 3-5 years[5] – meaning we never delete waivers and possibly include an expiresAt (if needed) or simply retain indefinitely. Add validation so that agreedToTerms must be true (the submission endpoint should reject if not). The waiver data should be exportable, so ensure the schema can easily be converted to CSV (all necessary fields are stored in a straightforward manner). We might also store a PDF copy path if waivers need to be downloaded in original format.
•	Ticket Model: Represents an admission ticket purchase. We can model each individual child admission as a Ticket document, or group them. A flexible approach: each Ticket document corresponds to a single child entry (so purchasing for 3 kids creates 3 Ticket docs). Fields: userId (who purchased), maybe childName or childId (if we want to associate a specific child), purchaseDate, pricePaid, and a unique code (string or QR code value) for redemption. The code can be a UUID or short random string generated upon creation. Also include a redeemed: Boolean (or a redeemedAt timestamp) to mark if it’s used. This way, staff can check a ticket’s code at the door and mark it used[6]. If tickets are always used on day-of purchase, we may not need an expiration, but if pre-purchased tickets are allowed, we might include a valid date or event association.
•	Sibling bundle pricing: The pricing logic (not in schema, but logic) will ensure if multiple tickets are bought in one order, the appropriate discount is applied (e.g. 2 kids = $35, 3 kids = $50[7]). We will implement that in the purchase endpoint (see Backend API).
•	Membership Model: Represents a membership subscription for unlimited or discounted visits. Fields: userId (the member), tier (e.g. "Silver", "Gold", "Platinum", "VIP Platinum"), startDate, endDate (for fixed-term memberships or current period for recurring), autoRenew: Boolean, and details like visitsRemaining or visitsUsedThisPeriod if applicable (e.g. Silver might allow X visits per month). Also store active: Boolean or derive active status based on dates. The membership can also have a stripeSubscriptionId if we integrate with Stripe subscriptions for auto-renew. Ensure membership tiers and benefits are predefined (we’ll seed these). For example, we seed a collection or config for membership types: Silver (maybe 5 visits/month), Gold (10 visits/month, some discounts), Platinum (unlimited visits, maybe guest passes), VIP Platinum (all perks). The Membership model should track usage and renewal. We also include a field for autoRenew to indicate if the user enabled recurring billing[8].
•	PartyBooking Model: Represents a birthday party reservation. Fields:
•	userId (who booked the party),
•	date and startTime (the scheduled time) and compute endTime as start + 2 hours (enforce 2-hour sessions)[9],
•	packageType (the type of party package chosen, e.g. preset packages like "Basic", "Deluxe" which we will seed with base prices and included guest count),
•	childrenCount (number of children expected, to possibly validate against package limits or calculate extra child add-ons),
•	addOns (array of add-on services chosen, e.g. "Extra Hour", "Extra Child", "Face Painting", "Photo & Video" – each with a set price[10]). We can store this as an array of strings or an array of {name, price} objects for clarity,
•	totalPrice (computed total for the booking including add-ons and fees),
•	depositAmount (50% of total, which is required upfront)[11],
•	cleaningFee ($50 flat, always included)[11],
•	status (e.g. "Pending Payment", "Confirmed", "Cancelled"),
•	paymentId or reference to a Payment record (if we store payment info separately),
•	possibly location if multi-location (for now maybe a single location, but we include a field for future expansion and use the location selector in UI[12]),
•	notes or special requests if any. Ensure that when writing this schema, we enforce the business rules: sessions are 2 hours and should not overlap. We might add a mongoose pre-save hook or simply rely on application logic to check conflicts. Cleaning buffer: not explicitly a field, but when querying availability or saving, ensure no booking starts within 30 minutes of this booking’s end[12]. (This rule will be enforced in the backend service logic rather than the schema, by querying for conflicting bookings).
•	Event Model: Represents special events (aside from regular play). Fields: title, description, date (or start/end datetime if needed), category or type (we can seed Event Categories like "Sensory Friendly", "Character Visit", "Holiday Party"), capacity (if limited), price (if tickets needed) or a flag if free with membership, etc. Also include fields for images or highlights (for marketing). For RSVP and ticketing: if an event requires ticket purchase, we might link to Ticket or create specialized EventTicket entries. Simpler: include a field requiresTicket: Boolean and if true, the frontend will direct user to buy a ticket for that event (which could internally just call the Ticket purchase endpoint with an event reference). If free RSVP, maintain a list of RSVPs: could be a subdocument array of { userId, childrenCount } or have a separate RSVP model. To keep it simple, we can allow an endpoint to mark a user as RSVPed in an array in the Event model (attendees: [{ userId, count }]). Ensure to store events in their own collection for easy querying of upcoming events.
•	Payment Model: Store records of payments and transactions for traceability. Fields: userId, amount, currency, paymentMethod (card, etc.), status ("succeeded", "failed", "pending"), stripePaymentIntentId (or stripeChargeId) for reference, purpose (could be "Ticket Purchase", "Membership", "PartyBooking deposit", etc.), and any metadata (like which booking or membership it was for). This is useful for auditing and refund handling. Many of these fields will come from Stripe webhooks (see Payments integration below).
•	AdminLog Model: Keep an audit log of admin actions. Fields: adminId (ref User), action (string description like "Cancelled Booking", "Edited Membership", etc.), targetId (optional reference to an entity affected, like a booking ID), timestamp. This helps with accountability and can feed the admin dashboard (recent activity feed). Every time an admin uses special admin endpoints, we create a log entry.
Schema Validation & Indexes: Use Mongoose schema options to enforce required fields and basic validation. For example, mark email as required and match email regex, require waiver’s terms checkbox to be true. Set up unique indexes on fields like email (for User) and maybe code (for Ticket code). Use appropriate data types (Date for dates, Boolean, Number for prices etc.). The relationships use ObjectId references as noted (ensuring to use ref so we can populate if needed[4]). In some cases, we embed small subdocuments (like children info inside a Waiver for snapshot), but generally prefer references to avoid duplication.
Seeding Initial Data: Upon application startup (or via a script), insert base data: - Membership tiers: create documents for each tier with their benefits (could be in a separate collection or just as an enum config). Alternatively, since tier info might be mostly static, we can hardcode a config object. But storing in DB allows admin to tweak pricing via the dashboard in future. We’ll seed e.g.: Silver – \$X/month, Y visits/month; Gold – \$Y, etc. - Event categories or some sample events if needed (e.g. category "Holiday" etc.). - Party package presets: define types like "Basic Party" (e.g. up to 10 kids for \$BasePrice), "Deluxe Party" (maybe includes something). This could be a collection or just part of configuration used by frontend. To implement dynamic pricing, the backend might store rules for pricing (like base price covers N kids, extra child costs \$40). For now, we have specific add-on prices[10], but base party price might be fixed (not given explicitly; we can assume a base price e.g. \$300 for 2 hours as an example). We will document these assumptions. - Roles: if using a roles collection (like BezKoder example does for user roles[13]), seed default roles ("user", "admin"). However, since roles are few, we could simply use an enum and embed role in User without separate collection.
Seeding can be done similar to an initial() function that runs on server start if collections are empty[14]. For example, check if membership types exist, if not insert the preset types. This ensures required data is available on first run.
3. Backend API (Express/Node.js)
Develop a comprehensive RESTful API to support all application features. The Express app will be structured into routers/controllers for each domain (auth, users, waivers, tickets, memberships, bookings, events, admin). Use JWT authentication for protected routes and role-based authorization for admin functionality. Below are the major API endpoints and their implementation details:
Authentication & User Accounts
•	User Registration (POST /api/auth/register): Accepts name, email, password (and possibly other info like phone). Validate the email isn’t already in use and password strength. Hash the password with bcrypt before saving the new User. Create and return a JWT on success so the user can be logged in immediately. Possibly also create an initial empty waiver or prompt to fill waiver after signup.
•	User Login (POST /api/auth/login): Verify email and password. If valid, generate a JWT signed with our secret (store secret in env). The JWT payload will include user ID and role. On login, also return user profile info (or there will be a separate profile fetch).
•	JWT Middleware: Implement authMiddleware to protect routes. It will check for a token in the Authorization: Bearer <token> header (or a custom header) and verify it with jwt.verify using our secret[15]. If invalid or missing, respond 401. If valid, attach req.userId (and maybe req.userRole) for use in handlers[16].
•	Role Middleware: For admin-only routes, create e.g. roleMiddleware("admin") that runs after authMiddleware. It will fetch the user (or decode token claims if we put role in token) and check if the role is admin. If not, respond 403 Forbidden[17]. Keep roles simple (user vs admin). This is similar to the isAdmin check in many JWT examples[18][17].
User Profile & Children Management
•	Get User Profile (GET /api/users/me): Protected by JWT. Retrieves the user’s profile info including their children, current membership status, etc. This can use Mongoose populate to fetch related children documents if we stored child references in User[4]. Alternatively, query Child model by userId. Do not return sensitive info like password hash. This endpoint allows the frontend to display user’s info and status after login.
•	Update User Profile (PUT /api/users/me): Allow user to update their name, contact info, etc. Also possibly allow password change (with proper current password verify and re-hash new password if provided). Email changes might require re-verification (out of scope unless needed). Ensure to validate inputs.
•	Manage Children (POST /api/users/me/children and DELETE or PUT for updates): Parents can add child profiles. However, in our flow, a child is typically added when a waiver is submitted (since the waiver form collects child info). We can allow adding a child outside the waiver too. For instance, POST /children with child name, birthdate, gender creates a Child document linked to the current user. In response, return updated child list. Also allow removing or editing a child (if, say, a name was entered wrong). These routes should only affect the authenticated user’s children.
•	Note: The system will likely rely on the waiver process to capture children’s details, but separate endpoints provide flexibility (especially if an admin needs to manage children profiles or if the UI allows managing kids in profile settings).
Waiver Management
•	Submit Waiver (POST /api/waivers): This endpoint will handle the waiver form submission from the /waiver page. It requires authentication (the user must be logged in to sign a waiver). The payload includes the guardian’s name/email (we have it from user profile, but use provided to double-check), and an array of children info (each child’s name, birthdate, gender), plus the agreement checkbox flags.
•	Implementation: For each child in the form, if the child doesn’t already exist in the system under this user, create a new Child entry (so they can be referenced later). Alternatively, we could simply store the child info inside the Waiver record without separate Child entries. However, having Child entries is useful for future uses (e.g. quick selection for party attendees or check-in). We’ll do both: create/update Child records and also record the children details in the Waiver record (snapshot).
•	Save a new Waiver document with references to the created children (or embedded children data), mark agreedAt = now, store the consent flags. Ensure termsAgreed is true or reject. Save this waiver.
•	Possibly mark the User as having a valid waiver on file. We could add a field on User like latestWaiverId or a boolean waiverSigned for quick checks. Or simply query waivers when needed. For performance, adding a flag or referencing the latest waiver date in User could help ensure they have a current waiver (some venues require a new waiver every year, but requirement doesn’t say expiration, just long retention).
•	Download/Export: Provide an Admin endpoint to download all waivers or a certain range as CSV/Excel[19]. For example, GET /api/admin/waivers/export?format=csv. This will be protected and will gather all waiver records (with user contact and children info) to allow marketing or legal use. Implement using a CSV library or simply JSON output that an admin can copy. Given the small scope, even a JSON export might suffice, but CSV is specifically mentioned. We’ll implement CSV generation on the fly.
•	Secure Storage: The waivers are stored in MongoDB which is secure behind the backend. For additional legal safety, we might also generate a PDF of the waiver with an electronic signature timestamp, but that’s beyond scope. We ensure that our DB backups (if any) preserve these records for >=5 years.
•	Optionally, email a copy of the signed waiver to the user’s email for their records (this would use an email service).
•	Get Waiver (GET /api/waivers/latest): For the frontend to know if user has a signed waiver, we might provide an endpoint that returns the last signed waiver details (or at least a boolean). This can help enforce waiver-before-purchase: e.g., the checkout page can call this to confirm waiver exists. Alternatively, include a flag in the user profile response (e.g. user.waiverOnFile = true if a waiver exists).
•	Admin Waiver List (GET /api/admin/waivers): Returns a paginated list of all waivers in the system, including user info and timestamp, for staff review. (This pairs with the export functionality.)
Ticket Purchasing & Redemption
•	Ticket Pricing: The pricing logic is as follows – Base price \$20 per child, but sibling bundles: 2 kids for \$35, 3 kids for \$50[7]. This implies a discount for multiple children. We interpret this as \$20 for the first child and \$15 for each additional child beyond one (since 1 kid \$20; 2 kids \$20+15=\$35; 3 kids \$20+15+15=\$50). We will implement it that way (and for 4 kids, would be \$65, etc.). This will be confirmed on the Buy Ticket page as the user selects a number of kids.
•	Buy Ticket (POST /api/tickets/purchase): User selects how many children to buy tickets for (and possibly for which date, though it sounds like general admission tickets rather than event tickets). The request includes quantity of children (and perhaps their names if needed, or we can just count). The backend calculates the total price with sibling discount applied. It then integrates with Stripe to handle payment:
•	Create a Stripe Payment Intent for the calculated amount (e.g. 2 kids -> \$35) in the server side using Stripe SDK. We will use Stripe’s secret key from env to create the payment intent (with currency, amount, description like "Playfunia Admission Tickets"). This returns a client secret to complete payment.
•	Send the client secret to the frontend so the user can use Stripe Elements or Checkout to pay securely. Alternatively, implement Stripe Checkout Session (redirect to Stripe’s hosted page). But since we need a combined cart flow, using Payment Intents with Stripe Elements is suitable[20][21]. The frontend will confirm the payment and then call our backend webhook (or poll) for success.
•	Once Stripe confirms payment success (via webhook), our backend finalizes the ticket purchase: create Ticket records for each child ticket. Generate unique codes for each. For example, if 3 tickets, create 3 entries with redeemed=false and unique codes. We can use a short UUID or an npm package for code generation.
•	If the user is required to have a waiver before buying: we enforce that either in frontend (by disabling purchase until waiver done) and in backend (the endpoint can check if user has a waiver; if not, respond with error instructing to complete waiver). This addresses the requirement that waiver must be completed before entry[22].
•	Respond with a confirmation containing the ticket codes or a summary. Also trigger an email sending the digital tickets (each code, maybe a QR image or just alphanumeric code, and instructions).
•	Ticket Redemption (POST /api/tickets/redeem): An endpoint for staff/admin use. It takes a ticket code (scanned or typed at entry) and marks that ticket as used. It will set redeemed=true and possibly record redeemedAt and which staff (if we pass admin ID from token). If a code is not found or already redeemed, return an error so staff knows (e.g. "Invalid or already used"). This endpoint is protected (only admins or maybe a special role can redeem). The admin dashboard will have a UI for this or staff might use a separate simple app or the same admin UI.
•	List Tickets (GET /api/admin/tickets): Admin route to view ticket sales and usage logs. This can list recent ticket purchases, and allow filtering by used/unused[23]. For example, show all unused tickets (to see how many people are expected) or all used (for that day’s count). This data helps in the admin dashboard stats (e.g. daily entries).
Membership Management
•	Membership Plans Info (GET /api/memberships/plans): A public or user endpoint to fetch available membership tiers and their benefits, so the frontend can display the Membership Page tier list[24]. This data comes from the seeded membership types. For each tier: name, price (monthly vs yearly), benefits (like visits per month, discount percentage, guest passes count, etc.), perhaps an ID for purchase reference.
•	Purchase Membership (POST /api/memberships/purchase): Allows a user to subscribe to a membership. This could be implemented in two ways:
•	Stripe Subscription: If using Stripe’s recurring subscriptions, we would create a Customer in Stripe (if not exists), then create a Subscription to a Stripe Product/Price that corresponds to the selected tier (Stripe products for Silver/Gold/etc monthly or yearly). This way, Stripe handles charging monthly and we get webhook events for payment succeeded/failed. The endpoint would orchestrate this: accept tier and billing period (monthly/yearly), call Stripe to create a subscription checkout session or direct subscription, then redirect or return session ID to frontend to complete. Once done, webhook will activate membership.
•	One-time Charge + Auto-Renew flag: Alternatively, handle recurring manually: charge the user for the membership period and store autoRenew=true in our DB. But then we'd have to charge again next period, which is complicated. It’s better to use Stripe’s subscription mechanism for auto-renewing memberships. Given the requirement of auto-renew toggle[8], implementing via Stripe subscriptions is appropriate. We’ll prepare the backend with Stripe product IDs for each membership tier and code to create/cancel subscriptions.
•	Activate Membership: When a membership purchase is completed (either immediately after a one-time payment or via webhook for subscription), we create a Membership document for the user:
•	Set the tier, mark startDate=now, endDate based on period (e.g. +1 month or +1 year if yearly membership).
•	If recurring, we might leave endDate open or set it to the initial period but auto-extend on renew.
•	Mark active=true. If the user already had a membership, either upgrade/downgrade logic or prevent duplicates (likely only one active membership per user at a time).
•	If membership includes limited visits per period, initialize visitsUsed=0 for the current period.
•	Membership Usage (POST /api/memberships/use or via check-in): Staff will need a way to record when a member visits (to decrement their allowed visits). Possibly an admin endpoint /api/admin/memberships/checkin?user=email that finds a user’s membership, checks if they have visits remaining this period (if tier has a limit), and if so, increments usage and returns success or if not, deny entry (or charge an extra fee). This corresponds to Membership entry validation panel in admin dashboard where staff can input a member identifier and see if they can enter[25][26]. We will implement logic to compute remaining visits: e.g., Silver allows 5 visits/month – if user has used 5 and tries 6th, API responds they’ve reached their limit.
•	Possibly provide a reset mechanism monthly: a scheduled job or when checking in, if current date is beyond the month of startDate, reset visits count and set new period start.
•	Cancel Membership (POST /api/memberships/cancel): If user wants to cancel auto-renew (or an admin cancels), handle accordingly. If Stripe subscription, cancel it via Stripe API which will set it to not renew. Update our DB autoRenew=false and maybe set membership to expire at period end.
•	Membership Status (GET /api/memberships/status): Alternatively, this can be part of profile or a dedicated endpoint to retrieve the user’s current membership details (tier, next billing date, visits remaining, etc.). This is useful for the account page or membership page if user already subscribed.
Party Booking System
•	Check Availability (GET /api/parties/availability?date=YYYY-MM-DD): Returns available time slots for that date (or a range). The logic: we know each party is 2 hours and requires a 30-min buffer after[9]. We may define allowed start times (e.g., if business hours are 10am–8pm, the slots could be 10:00, 12:30, 3:00, 5:30 for example, each slot being 2.5h apart). Alternatively, do a free-form check:
•	Query the PartyBooking collection for any booking on that date. For each existing booking, block its timeslot ± 30min after it.
•	Determine open slots (in half-hour increments, perhaps) that are 2h long without overlap.
•	This can be a bit complex; a simpler approach is to have discrete preset slots. We might assume parties start every 2.5 hours. However, to keep flexible, implement a function that given a desired start time, checks if it conflicts with any existing booking (booking.start < desiredStart < booking.end+buffer). For availability, we can just return existing bookings and let frontend compute or present free times to pick. But better to compute server-side to ensure correctness.
•	This endpoint will feed the Book a Party page’s interactive calendar[12]. The frontend could show a calendar where user picks a date, then time slots available.
•	Create Party Booking (POST /api/parties): User chooses a date & start time, selects a package and any add-ons, and provides party details (maybe child’s name whose birthday, etc.). This endpoint will:
•	Validate the selected slot is still free (perform the same conflict check just before booking).
•	Calculate the price: base price for the package plus add-ons costs. Then add the mandatory $50 cleaning fee[11]. Compute the required deposit = 50% of the total (after adding cleaning and add-ons)[11]. For example, if base $300 + extra hour $100 => $400 + cleaning $50 = $450 total, deposit = $225.
•	Create a PartyBooking entry with status "Pending Payment" or similar, including all details and prices.
•	Initiate payment: similar to tickets, create a Stripe Payment Intent for the deposit amount (not the full amount, if following the deposit model). Alternatively, charge full amount but allow 50% refund if cancelled – but requirement explicitly says 50% deposit, so likely only charge half now. We will charge the deposit now to secure booking.
•	Return the Payment Intent info (client secret) to frontend for card payment. After successful payment (Stripe webhook), update the PartyBooking status to "Confirmed" and mark deposit paid. Perhaps also store a Stripe transaction ID in the Payment model.
•	Email confirmation to user with booking details (date/time, package, amount paid and due). Indicate that the remaining balance (50%) will be due on the day of the party (or charged later). In a full system, we might capture card for later charge or invoice the remainder, but for now we assume offline payment of remainder.
•	If the user doesn’t complete payment, the booking could remain pending for a short time and then be released. (We might implement a cron to cancel unpaid bookings after X hours).
•	List Party Bookings (GET /api/users/me/parties): User can view their party reservations (upcoming or past). This helps on their profile or a “My Bookings” page.
•	Cancel Booking (POST /api/parties/{id}/cancel): Allow user to cancel their booking (maybe with some advance notice policy). If within allowed time, process the cancellation:
•	If deposit was paid, decide refund or not. It’s common that deposits are non-refundable if close to event. The system could allow cancellation and mark for admin to process refund manually (if we do Stripe refunds, integrate that). To simplify: we’ll allow cancellation but indicate they need to contact for refund or say deposit non-refundable (depending on business policy).
•	Mark booking status "Cancelled". Free up the slot for availability.
•	Send cancellation email.
•	Admin Booking Management (GET /api/admin/bookings & PUT /api/admin/bookings/{id}): Admins can view all bookings (with filters like date)[27]. They should be able to edit or override details – e.g., change the time, adjust package, or cancel on behalf of user. Implement an update endpoint that allows modifying a booking (with the same validation on time slot). Also possibly an endpoint to manually create a booking in admin (for phone reservations).
•	Enforcing Rules: The backend should enforce the key rules:
•	Exactly 2 hour sessions, auto-lock so overlap is prevented[28] (achieved by conflict check).
•	30 min cleaning buffer[12] (conflict check includes this buffer).
•	Always add $50 cleaning fee to price[29].
•	Only allow booking if user has signed waiver (could check user’s waiver status; alternatively require waiver at checkout, but since party booking checkout includes waiver step, ensure they cannot finalize without one).
•	The checkout flow for booking in frontend will likely incorporate waiver signing if not done (i.e., before payment, prompt waiver).
•	Deposit enforcement: do not allow confirming booking without at least deposit paid (and reflect remaining balance somewhere for admin).
Payments Integration (Stripe Webhooks)
Implement Stripe integration for secure payments: - Use Stripe’s Node SDK on the backend. Configure it with the secret key from env. - For one-time payments (tickets, deposits, one-off membership): use Payment Intents. The backend endpoint creates an intent and sends client_secret to frontend[20]. The frontend will use Stripe’s libraries (@stripe/react-stripe-js) to handle card input and confirmation. - For subscriptions (memberships auto-renew): configure Stripe products/prices and use either Checkout or the Subscription API. Possibly the backend creates a Checkout Session and returns the URL for the frontend to redirect. Webhook will handle the result. - Stripe Webhook Endpoint (POST /api/webhook/stripe): Set up a webhook route to receive Stripe events (the path should be an express route and we’ll register it with Stripe). In Stripe dashboard or CLI, subscribe to relevant events: payment_intent.succeeded, payment_intent.payment_failed, checkout.session.completed (for subscription sign-ups), invoice.payment_succeeded (for recurring payments), etc. The webhook handler will verify the event (using Stripe’s signing secret if provided) and then inspect event types: - On payment_intent.succeeded: Determine what payment it was (check metadata or store mapping from client – we can attach metadata like type=ticket or an internal order ID when creating the intent[30]). Then perform post-payment actions: e.g., if it was a ticket purchase, create the Ticket documents and email them. If it was a party deposit, mark booking confirmed. If membership purchase one-time, activate membership. - On checkout.session.completed for a subscription: create the Membership record in our DB (the session will have the subscription ID). - On invoice.payment_succeeded for subscription renewals: could update membership endDate for next period and set visits count to 0 for new period. - Handle payment_intent.failed or invoice.payment_failed by notifying user or marking something as unpaid. - Always respond 200 quickly to Stripe after processing[31][32], to acknowledge receipt (Stripe requires a 2xx response). - Security: Secure the webhook endpoint by verifying Stripe’s signature header using the webhook secret[33]. This prevents fake calls. - Payments Data: Record each transaction in the Payment model. The webhook can create a Payment entry with details from the event. For example, on success, store amount, type, and link to the related entity. This provides an audit log and allows building revenue reports in admin. - The backend should never expose Stripe secret keys to the frontend. All sensitive operations happen server-side (creating intents, handling webhooks)[21]. The front-end only gets the publishable key (for Stripe Elements) and client secrets. This ensures PCI compliance and security.
Event Management
•	List Events (GET /api/events): Returns upcoming events (and possibly past events separately). This populates the Events page with a calendar or list[34]. Support filtering by date or category. For each event, include details needed: name, date/time, description, whether tickets are required, etc.
•	Event Details (GET /api/events/{id}): Returns full info on a specific event, including maybe an image gallery or detailed schedule.
•	RSVP to Event (POST /api/events/{id}/rsvp): Allows a logged-in user to RSVP for a free event. Simply add their name (and maybe number of kids attending) to the event’s attendee list. Enforce any capacity limit. Confirmation can be an email or just success message. This increases that event’s RSVP count.
•	Purchase Event Ticket: If an event requires a paid ticket (e.g. a holiday party with $5 fee), this would essentially be similar to buying a regular ticket but tied to an event. We can implement as part of the ticket purchase endpoint by including an eventId. If eventId is present, ensure that the Ticket entries created reference that event (add eventId field in Ticket model). The frontend Events page could link to the /buy-ticket flow pre-filled for that event. Alternatively, provide a dedicated endpoint /api/events/{id}/purchase which wraps the ticket purchase logic for that event.
•	Admin Event CRUD: Admins need to create and edit events via the dashboard[27]. Implement:
•	Create Event (POST /api/admin/events): Accept event data and insert into Events collection. Possibly allow image upload (could integrate with an S3 or just store URL to an uploaded image).
•	Edit Event (PUT /api/admin/events/{id}): Update fields.
•	Delete Event (DELETE /api/admin/events/{id}): Remove an event (maybe only if no attendees or just allow deletion).
•	These are protected by admin role.
Admin Dashboard & Management
Provide a set of endpoints to support admin functionalities for the internal dashboard: - Admin Login: Admins can log in via the same auth endpoints (they are just users with role: admin). The JWT will indicate their role. - Overview Stats (GET /api/admin/stats): Gather summary numbers for the dashboard home: e.g. total tickets sold today, total upcoming parties, active memberships count, etc. This may aggregate data from multiple collections. For example: - Tickets: count of tickets sold today/week, and how many redeemed today. - Parties: count of upcoming bookings, maybe revenue from bookings. - Memberships: count active, new signups this month. - Waivers: count of new waivers in last week (as proxy for new customers). This gives the admin a quick overview. - User Management (GET /api/admin/users): List users (with pagination). For each user, include profile info, number of children, membership status, etc. Possibly allow searching by email or name. - Edit User (PUT /api/admin/users/{id}): Allow admin to update a user’s info or role (promote someone to admin, etc.), or deactivate a user if needed. - View User Details (GET /api/admin/users/{id}): Fetch user plus their children, memberships, bookings, tickets, waivers for a detailed view. This helps if a customer calls support – staff can look up everything about their account. - Waiver Export (described above) and User Contact List Export: Similar to waivers, allow admin to export all user emails (for marketing). This could be a simple CSV of name, email for all users who opted in to marketing (we have a marketingPermission flag on waiver)[35]. Implement at GET /api/admin/users/export?marketingOnly=true. - Booking Management: (as above) admin can list all bookings and modify them. Possibly an endpoint to directly mark a booking as paid (if someone paid offline). - Ticket Logs: (as above) list tickets, filter by used/unused, by date. Possibly an endpoint to mark redemption (but we have a separate redeem endpoint). - Membership Management: Admin might want to see all memberships or adjust one. Endpoints to list memberships (which users at what tier, usage). Possibly allow admin to manually set a user’s membership (e.g. grant a free membership or adjust remaining visits). - Admin Logs: Although not explicitly requested in UI, we keep AdminLog entries. We could provide an endpoint to list recent admin actions for audit. - All admin endpoints will use the authMiddleware and roleMiddleware("admin") to ensure only authorized staff access them.
Note on Admin UI security: The dashboard is not publicly linked and requires login. The API should still enforce checks server-side (never rely solely on frontend hiding links).
4. Frontend Application (React) Pages and Components
The React frontend will provide a user-friendly interface for all features. We’ll use React Router to define routes corresponding to each page specified. Use a modern UI approach with either Tailwind CSS for custom styling or Material UI for ready components – here we choose TailwindCSS for a playful, custom design aesthetic, given the child-friendly theme. We’ll ensure a responsive design and good accessibility practices. Below are the key pages and their contents (aligned with the provided PDF requirements):
Home Page (/)
This is the landing page and should immediately convey fun and branding: - Design: A visually attractive, colorful layout with child-friendly graphics (bright colors, playful fonts)[36]. Possibly include images of kids playing or cartoon illustrations for appeal. - Hero Section: Prominent branding statement/tagline (e.g. “The most fun indoor playground experience for kids!”) as given in the requirements[36]. Below that, place primary Call-To-Action buttons: “Book a Party”, “Buy a Ticket”, “Become a Member” – clearly visible without scrolling[37]. These buttons should navigate to the respective pages. - Play Zone Highlights: Showcase the different play areas (trampoline zone, ball pit, toddler area, etc.) in a section with icons or small photos and short descriptions[38]. This gives parents a glimpse of facilities. - Social Proof: Embed a live Instagram feed or a gallery of recent social media photos to show real kids playing (if feasible)[39]. Alternatively, a static gallery updated periodically. This adds current activity vibe. - Announcements Banner: A strip or card for current promotions or special notes (e.g., “Holiday Special: 20% off parties booked in December!”, or “Sensory-friendly hours every Tuesday 4-6pm”)[39]. This can be a carousel for multiple messages or a single banner that updates. - Testimonials (Optional): A section with one or two short testimonials or reviews from parents, adding trust and positive feedback[40]. - Footer: Include contact info snippet, social media links, and maybe hours.
All key info is above or not far below the fold to quickly inform the user. The Home page will use React components for each subsection (Hero, Highlights, etc.) and fetch any dynamic content (like latest events or Instagram feed data via an API if available). We ensure the calls to action stand out (perhaps styled as large, bright buttons).
Book a Party Page (/book-party)
This page allows users to schedule a birthday party event at Playfunia. It will integrate with the backend to show availability and take bookings: - Location Selector: If multi-location is ever supported, include a dropdown at top for location[12]. For now, we have a single location, but we will include a disabled or hidden selector to anticipate future expansion. - Interactive Calendar: Display a calendar view where the user can pick a date. When a date is selected, show available time slots for that day[12]. We will call the backend availability API to get free slots. The UI may highlight slots (e.g., 10:00am–12:00pm) that are open. Slots that are taken or blocked (including the 30 min buffers) will be marked unavailable. We enforce that when a slot is chosen, 2-hour duration is set and adjacent slots are blocked out in the UI. - Party Details Form: The user selects a party package (perhaps radio buttons or a dropdown for package type, if multiple tiers of party are offered – e.g., Basic vs Deluxe). Then they can select Add-ons from the list: Extra Hour ($100), Extra Child ($40), Face Painting ($100), Photo & Video ($250)[10]. These will be checkboxes or toggles. As they make selections: - Dynamic Pricing Display: Calculate and display the running total price in real-time[29]. For instance, base price + add-ons + cleaning fee. If the user selects “Extra Hour”, add $100, etc. The cleaning fee $50 will always be added once they start booking (we can show it as a line item). - Show a summary of selections (package name, selected add-ons, number of kids if package has a limit and extras) in a cart summary sidebar or section[41]. The summary should list: Base price, Add-ons, Cleaning Fee ($50)[29], and total. We might also calculate the required deposit (50% of total) and display that info (e.g., “Deposit due now: $X”). - Time Slot Auto-Lock: Once a user selects a slot and starts the booking process, we might temporarily reserve that slot on the frontend (and backend can optionally lock it if multiple users could try same slot – but since local, concurrency is low; we will just final check on submit). The UI can indicate that the session is 2 hours and no overlap is allowed[28]. - Waiver Requirement: On this page or at checkout, remind the user that a waiver must be signed prior to party date. Possibly include a note or link: “You will be required to sign a waiver for your children before checkout.” This ties into the checkout process. - Checkout Process Launch: The Book Party page will have a “Proceed to Checkout” button or modal once all details are selected[42]. Clicking this will initiate the payment flow: - If the user is not logged in, prompt login/signup (since booking requires an account for waiver signing and management). - If user has not signed a waiver yet, prompt them to fill out the waiver form (possibly integrate the waiver form here or redirect to /waiver then return). - Finally, collect payment (via Stripe). Likely this page will transition to a unified Checkout page or use a multi-step modal. Given the requirement for a combined cart and checkout page, we might redirect to /checkout carrying the party booking info as an item in the cart. - UI feedback: After successful booking, show a confirmation with booking details. If on a separate confirmation page, include date/time, “Deposit paid: $X, Remaining balance: $Y to be paid on event day.” And include any instructions (like arrive 15 min early, outside food policy, etc., which might be in FAQs).
All the above elements ensure the user can seamlessly schedule a party and know the costs upfront[41]. We carefully prevent selection of invalid combinations (e.g., cannot select Extra Hour that causes overlap with next booking – the backend will enforce, and UI can warn if time conflict).
Waiver Page (/waiver)
This page is a form for the liability waiver that guardians must sign[43]. It’s a crucial step that might be completed standalone or during checkout. - Guardian Info: Fields for the parent/guardian’s full name and email address[44]. If the user is logged in and we have their name/email, we pre-fill these fields (but still allow editing if, say, a different guardian is signing). - Children Info: The form allows entering multiple children. Provide inputs for each child’s Name, Birthdate, and Gender[44]. Use a dynamic form where user can click “Add another child” to append another row of child inputs. Include basic validation (e.g., no empty name, reasonable birthdate). - Agreements: A required checkbox for “I agree to the Terms & Conditions” (the actual text or a link to terms)[45]. The user must check this to submit. Also an optional checkbox like “I consent to receive marketing emails”[35]. - Submit and Confirmation: On submit, call the /api/waivers endpoint with this info. If successful, show a confirmation message like “Thank you for signing the waiver. Your information has been saved.” Possibly email a copy. In the UI, after submission, if this was part of checkout flow, redirect back to checkout. - Data Handling: The UI should make it clear that the data is stored securely and used for legal purposes[46]. Could add a note: “Waivers are stored for at least 5 years for legal accountability.” This aligns with requirements. - Download prompt: Not required for users, but maybe after signing, offer “Download a copy of your signed waiver” (if backend can generate a PDF or even just a summary page to print). This is an enhancement.
Accessibility: ensure forms are properly labeled. Use date pickers for birthdates for ease. Also, if needed, incorporate digital signature capture (not explicitly required, so we assume checking the box suffices as e-signature).
Buy Ticket Page (/buy-ticket)
A page for purchasing general admission tickets for playtime: - Ticket Pricing Display: Clearly show the pricing structure: $20 per child and special sibling bundle rates (e.g., 2 kids = $35, 3 kids = $50)[7]. This can be presented as a small table or just text so parents immediately see the deal. - Ticket Form: The main input is the Number of Children the user wants to bring. This could be a dropdown or stepper (1, 2, 3, ...). When the user selects a number, use JavaScript to automatically calculate the total price with the bundle discount applied[7]. For example, if “3” is selected, display “Total: $50” instead of $60. This gives instant feedback. - Optionally, allow them to provide names of children (not strictly necessary; can just buy X tickets). But might not be needed unless tying to specific child profiles. - Waiver Reminder: Prominently remind users that they must have a signed waiver on file before using the tickets[47]. For example, a message below the form: “Reminder: A signed waiver is required for all children before entry. Complete your waiver.” If the user is logged in, we can check if they have a waiver and display a green check “Waiver on file” or a warning icon if not. - Checkout Button: A button “Proceed to Checkout” or “Buy Now” that initiates payment. This will add the ticket purchase to the Cart/Checkout process (if using a combined cart, it might redirect to /checkout with this item). If we’re doing a quick purchase (maybe separate from cart), it could open a Stripe payment modal directly. However, since the design calls for a combined cart page, likely we add to cart and then go to /checkout. - Post-Purchase Confirmation: After payment, show a confirmation page or message: “Thank you for your purchase! Your digital tickets have been issued to your account/email.” Include the unique code(s) for the tickets (or state they will receive via email). Possibly list each ticket code and instructions: “Present this code at the door for check-in.” - We will ensure that upon successful purchase, if on the web app, the UI could show the codes or a “View Tickets” link (which could go to the user’s profile where their tickets are listed). - If user attempts to proceed without a waiver, either block and prompt them to sign waiver first, or include the waiver step in checkout (we might decide to force the waiver step in the /checkout sequence if one is not done).
This page should be simple and focused on one thing: selecting quantity and paying, with minimal distractions.
Membership Page (/membership)
This page educates the user on membership options and facilitates subscription: - Tier Overview: List the available membership tiers: Silver, Gold, Platinum, VIP Platinum, including pricing and key benefits for each[24]. This could be a comparison table or a set of cards: - Each tier card shows: Price (monthly and yearly if applicable), how many visits per month, discount on additional tickets or parties, how many guest passes, etc. Use the data from backend /plans. For clarity, include a highlight (e.g., “Most Popular” on one of them if applicable). - Perhaps a toggle switch at top for “Monthly vs Annual” pricing view, so when toggled, the prices on all cards switch to the yearly rate (and possibly show one-time year payment, e.g., Silver $X/mo vs $Y/year). This satisfies the monthly/yearly toggle requirement[48]. - Benefits Comparison: Could have a comparison table below the cards, listing features vs tiers (e.g., “Free visits per month: 4 for Silver, 8 for Gold, Unlimited for Platinum”, “Guest Passes: 1, 2, 5...”, “Party Discount: 5%, 10%, 20%...” etc.)[48]. This helps users pick the right plan. - Auto-Renew Toggle: When the user goes to subscribe, allow them to opt in/out of auto-renew. Actually, for monthly plans, auto-renew is usually default (since it’s subscription). The UI could present it as a checkbox “Enable auto-renew (recurring billing)”[8]. If unchecked, maybe we treat it as a one-period purchase (though implementing one-off membership that expires is fine). - Subscribe Button: On each tier’s card, have a “Subscribe” or “Join [Tier]” button. Clicking it: - If user not logged in, prompt login (memberships tied to account). - Possibly open a modal or redirect to a dedicated checkout for membership. This might go to /checkout if we unify the flow, or could directly initiate Stripe Checkout. - We likely will handle membership purchase in the combined checkout too, to reuse payment logic. E.g., add “Silver Membership – $N” to cart and then checkout. - Post-Purchase: After subscribing, the page could show membership status: - If the user already has a membership, instead of showing subscribe options, show “You are a Gold Member. Next billing date: Jan 1, 2026. [Cancel auto-renew]”. Include info on their plan (visits used/remaining, etc.). Also provide an option to upgrade (prorate logic could be complex, perhaps not now) or cancel. - If admin or staff login to this page, maybe they see a search for members – but that likely belongs in admin dashboard, not here. - Membership Status Accessibility: Also ensure membership status is visible in user profile or a dashboard sidebar so they know when visiting the site that “Member: Yes (Gold)”.
Focus on clarity – parents should quickly grasp the value of each tier. Use icons or highlights for key perks. For example, “🥈 Silver: 4 visits/month, 5% off parties” etc.
Cart & Checkout Page (/checkout)
This is a central checkout that can handle one or multiple items (tickets, memberships, party deposits all together)[49]. It consolidates the purchase steps: - Cart Summary: At the top, list all items the user is about to purchase: - If they came from “Buy Ticket” with 3 kids, show “3 x Admission Tickets – $50”. - If also from “Book Party”, show “Birthday Party on [date] [time], [Package Name] – Deposit $X (Total $Y)”. - If a membership was added, show “Gold Membership (Monthly) – $50”. - Allow removal of items if they navigated away and came back with multiple (in case our flow allows adding multiple different items). If the flow is typically one item at a time, the cart might usually have one category of item. But supporting multi-item cart is a plus (e.g., user decides to get a membership and also book a party in one transaction). - Discounts and Promo Codes: If applicable, provide a field to enter a promo code. Also automatically apply any known discounts: - Sibling discount is already baked into ticket price calculations. - Membership discount on parties or tickets: If user is a member and buying something not covered by membership (like an extra ticket or party booking), apply their member discount automatically[49]. For example, Gold members might get 10% off party bookings – the backend can provide that info in membership benefits, and the frontend can show a line “Membership discount: -$X”. We’ll fetch user membership status on page load. - Waiver Validation: Before allowing payment, enforce that a waiver is signed[50]: - If the user’s waiverSigned flag is false (or no waiver record), display a prominent alert: “Action Required: You must sign the waiver before completing your purchase.” Provide a button/link to the Waiver page. Potentially, we can embed the waiver form right here as a step (e.g., a collapsible section or modal). - Only when waiver is done (check via API call or state update after returning from waiver page) do we enable the payment button. - Payment Integration: Integrate Stripe Elements or Checkout: - Collect credit card details securely. Since we might have multiple item types, using Stripe PaymentIntent for a combined amount is ideal. We will call a backend endpoint like /api/checkout/create-payment that calculates the grand total for all items in cart, creates a PaymentIntent (or multiple if needed) and returns the Stripe client secret. - Then use <CardElement> or the newer Payment Element component in React to let user enter card info. - Submit the payment and handle any errors (e.g., decline, or 3D Secure authentication if required – Stripe’s library will handle the modal for that). - Confirm Order: After successful payment, show a confirmation page or message. Ideally, redirect to /checkout/success or similar. The confirmation should summarize: - Order number (if we generate one, or just say “Purchase Complete”). - For tickets: display codes (and email sent note). - For membership: welcome them to the membership (e.g., “You are now a Gold member! Your benefits are active.”). - For party: confirm the booking details and that deposit is paid. - Send out emails accordingly (the backend would have triggered them). - The confirmation page could allow printing or further instructions (especially for the party booking, list what to do next). - If any item in cart required separate handling, ensure all are processed (our backend will likely break down the combined purchase: for example, if cart has a deposit and membership, it might handle each in one PaymentIntent or multiple. Simpler: treat it as one combined charge and then allocate to each purpose after webhook.) - UX: Use a stepper or clear sections: e.g., Cart Review -> Waiver Check -> Payment -> Done. Indicate the current step. Disable or hide Payment form until waiver is resolved.
By consolidating to one checkout, we minimize multiple payments and provide convenience. However, we must also ensure partial flows work (someone just buying tickets goes through quickly, someone with multiple items also can do it in one go).
Admin Dashboard (internal, not public route or maybe /admin)
The admin interface can be a separate part of the React app (or even a separate app, but for simplicity we can include it under admin routes and only render if admin user). - Admin Login: We can reuse the normal login page but ensure that an admin user logs in. Alternatively, have a distinct admin login page (but it hits same /auth/login endpoint). Once logged in as admin, the app can show admin UI. We’ll likely check user.role from JWT or profile and conditionally render admin components. - Dashboard Home: A quick overview with stats cards: - E.g., “Tickets sold today: X”, “Upcoming parties: Y”, “New memberships this week: Z”, etc. These values come from the /api/admin/stats endpoint. Possibly include small charts or at least numeric counts. This gives an at-a-glance business health view[51]. - Navigation: Sidebar or top menu for various sections: Users, Bookings, Waivers, Tickets, Memberships, Events, etc. - User Management UI: A table of users with columns: Name, Email, # of children, Membership status (active/inactive, tier), and maybe actions (View, Make Admin, etc.). Support searching by name/email. If click View, show a detail panel or page for that user: - Detail includes their info, list of children (with ages), list of signed waivers (dates), list of memberships (history or current), list of upcoming/past bookings, list of tickets purchased. Essentially an aggregate profile view. This allows customer service to answer queries quickly. - The admin can perform actions like reset password (if implemented), or manually add a membership to user, etc., from here. - Booking Management UI: Show upcoming party bookings in a list or calendar. Perhaps a calendar view for admins to see all bookings by date (useful for staff scheduling). Or a table with filtering by date. Each booking entry shows date/time, booker name, package, status, and an action to edit or cancel. An Edit Booking form allows changing date/time (with availability check), toggling add-ons, or marking payment adjustments. Admin can override things like waiving fees or changing status. - Waiver Management UI: Allow export as mentioned, but also display a list of waivers. Possibly not needed to list every waiver (could be thousands over years). Instead, allow search by guardian name/email to retrieve their waiver, or filter recent. Since export covers marketing needs, in-app UI can be minimal here. But listing all waivers with a download link might be okay for recent ones. - Ticket Sales & Redemption UI: A section showing recent ticket purchases (date, user, quantity, codes, amount, redeemed count). A filter to show only unused tickets. The redemption tool: This could be a simple input where staff types or scans a ticket code. On submit, call redeem API. Show a big green check or red X depending on result, with message (“Ticket valid, marked as used” or “Invalid/used ticket”). This interface should be quick and possibly accessible via a shortcut (maybe a separate page optimized for tablet at front desk). - Membership Validation UI: For checking visits, etc. Perhaps combined with the ticket redemption or separate. It could be a field to enter a member’s email or scan a member card (if they had one). On submit, display membership status: tier, visits left this period (if applicable), or if unlimited. Also a button “Mark Visit” which will increment their usage (through the API). If limit reached, show warning “No visits remaining – require purchase of ticket.”[26]. - Event Management UI: A CRUD interface for events. Possibly a form to create an event (title, date, etc.), and a list of events with edit/delete. Could incorporate an upload for event image (if we support images). - Admin UI Polish: Use a consistent admin template style (Material UI could be handy here, or a Tailwind admin theme). Ensure it’s responsive and accessible. The admin pages are not for general users, but still should be user-friendly for staff.
The admin dashboard is essentially a mini-application within the app. We will secure it by checking user’s role on each page (if non-admin somehow tries to access, we redirect to home).
5. LLM Chatbot Integration (FastAPI + OpenAI)
We will create an AI-powered chatbot assistant that can help users with common tasks via natural language. This involves the FastAPI service acting as middleware between the frontend and OpenAI's GPT model, with the ability to call backend functions as needed (function calling feature).
Chatbot API Design
•	Endpoint: The FastAPI app will expose POST /chat that the frontend can call with user messages. The request body will contain at least the user’s message (and possibly a user identifier or session ID).
•	OpenAI Setup: Use the OpenAI Python SDK to call the Chat Completion API with a model like gpt-4 (or gpt-3.5-turbo) and the functions parameter to enable function calling. We will define a set of function specifications in the API call corresponding to Playfunia actions:
•	book_party – parameters might include date, time, party type, number of kids or package, etc.
•	get_event_list – maybe a function that retrieves upcoming events (optionally filtered by date or category).
•	get_membership_info – provide info about memberships or the user’s own membership status.
•	purchase_tickets – parameters: number of kids (and maybe date if needed, though tickets aren’t date-specific), which then triggers ticket buying process.
•	submit_waiver – parameters: perhaps children info, but realistically the chatbot might just guide user to the waiver form. We could allow it to take children names and DOBs as dict.
•	contact_support – parameter: a message or issue description from the user. Each function will have a name and a JSON schema for parameters so the model knows how to format the call.
•	Function Calling Mechanism: When a user asks something like “I want to book a party on Saturday for 10 kids”, the model can decide to call book_party with appropriate arguments (date = that Saturday, children_count = 10, etc.). According to OpenAI’s function calling guide, the model will return a response including a function_call field with the function name and arguments[52][53]. It’s our job to execute that function on behalf of the model[54]. The FastAPI backend will do the following:
•	Call OpenAI with the user message and the list of function specs.
•	If the response contains a function_call, parse it. (e.g., function_call.name == "book_party" with some arguments).
•	Execute the corresponding internal function or trigger the appropriate backend API. For example, for book_party, our chatbot service can call the Express backend’s /api/parties endpoint (with a preset or dummy user if needed, or ideally include user context in the request). Alternatively, since this is local and integrated, the FastAPI could connect directly to the Mongo database or an internal module to create a booking. However, better to reuse the Express API to keep logic centralized.
•	Get the result of the function call. For booking, the result might be a confirmation or a failure message. For get_event_list, it would be data about events.
•	Then, we feed that result back to the OpenAI model (as a message of role "function" with the function’s output, or directly craft a final answer). The recommended approach is to add a message like: {"role": "function", "name": "book_party", "content": "...result JSON..."} and call the model again to let it generate a user-friendly answer[55][56]. This way, GPT can incorporate the result into a conversational reply.
•	Finally, return the assistant’s answer (or function result message) to the frontend.
•	Function Implementation Details:
•	Booking a party: The chatbot can collect details from the conversation (date, time, etc.). The book_party function in FastAPI will likely call the backend booking API. If user is logged in, we have their userID (we should include user context in the chat request from frontend). If not logged in, the bot might say “You need to log in to book a party.” For simplicity, assume the chat is available after login so we have a user context. The backend might return a confirmation or next steps (like payment needed). The chatbot can then respond, e.g., “I’ve reserved your party slot on Jan 20 at 3pm. To confirm, please proceed to payment.” Perhaps it provides a link or guidance.
•	Checking event list: The get_event_list function can fetch upcoming events from the database and return a summary. The model can then enumerate events in the reply (“This month we have: 1) Winter Wonderland on Dec 5, 2) Superhero Day on Dec 20, ...”).
•	Getting membership info: If user asks benefits or price of memberships, the chatbot can call this function which returns the membership tiers and details (from DB or a predefined dict). The assistant then explains each tier’s info[24]. If user asks “How many visits do I get with Gold?”, the bot can specifically answer from that data.
•	Purchasing tickets: The bot could directly help buy tickets. It might ask “How many children?” then call purchase_tickets with that number. The function could initiate the ticket purchase process (maybe even create a PaymentIntent). However, completing a payment via chat is tricky (you typically need card info which the bot can’t handle). So more realistically, the bot can guide the user: “For 2 children, it will cost $35. I have added this to your cart. Please visit the checkout page to complete payment.” The function might just prepare the cart and return a link. We might implement purchase_tickets to interface with our cart system (e.g., create a cart entry or a reserved order).
•	Submitting waivers: The bot could take child names and birthdates via conversation and then call submit_waiver. But verifying and inputting multiple names in chat might be cumbersome. Alternatively, the bot can provide a link to the waiver page. Possibly, submit_waiver could be used if user says “I have a 5 year old named Alice and a 3 year old named Bob” – the bot could parse that and call the waiver API. We’ll include the function for completeness but the UX might be easier to just direct to form.
•	Contacting support: If user says something like “I need help with something”, the bot can either handle common queries or escalate. The contact_support function might log the query or send an email to staff. E.g., it takes a message and perhaps creates a support ticket or email. The bot then replies, “I’ve forwarded your message to our support team. You will get a reply soon.” This function helps when the AI cannot handle the request or the user explicitly wants human support.
•	Conversation State: We need to maintain context across turns so the chatbot can have a conversation. For example, if user says “I want to book a party”, bot asks “What date?”, user says “Next Saturday”, the bot should remember we're booking a party. We achieve this by keeping a conversation history in the FastAPI session or in a database keyed by user. Likely, when the frontend calls /chat, it will include the past messages or a conversation ID. The FastAPI can store a list of messages (role+content) per session (in memory or Redis for example).
•	We will accumulate messages and send the relevant history to OpenAI each time, so it has context.
•	The function calling will also be part of messages: after model returns a function call, we append it and the function result as messages for the next call[57][58]. The conversation might look like: [User: "I want to book a party", Assistant: function call for book_party, Function (our system): returns result, Assistant: "Your party is booked..."]. Managing this sequence is key.
•	Security & Rate Limits: Only allow the chatbot to perform actions on behalf of an authenticated user and only for that user’s data. We wouldn’t want a user asking the bot “List all users” and it actually calling an admin API. We will not expose admin functions to the AI. We define only user-scoped functions. Also, we should sanitize inputs to functions and perhaps confirm with user for critical actions. For instance, the bot might say “Do you confirm booking on X date?” before finalizing (though initial scope may skip explicit confirmation).
•	OpenAI API usage: Ensure to load the API key from env and not expose it. Use reasonable settings (maybe temperature ~0.7 for a friendly tone). The cost of using GPT-4 might be high, but assuming limited usage it’s fine. We can fallback to GPT-3.5 if needed for cost.
•	According to OpenAI’s documentation, the model will not actually execute the function – that’s up to us[59]. We have full control to decide whether to allow the function call or not. We will implement checks if needed (e.g., if function arguments are nonsensical, we can refuse).
•	Example interaction flow:
•	User: "Can you book a party for me?"
•	Bot (via OpenAI): decides to call book_party and asks for details, or directly tries with defaults. Possibly it will respond with a question first due to our system prompt saying not to assume (we can set a system instruction like “Don’t confirm a booking without asking date/time”).
•	Let's say Bot asks: "Sure! What date and time did you have in mind?" (The model might not immediately call function if info missing).
•	User: "Next Saturday at 3pm for 10 kids."
•	Bot: now has info, it calls book_party(date=..., time=..., count=10).
•	Our FastAPI executes: calls backend, gets availability -> slot free -> creates booking with deposit required (or tentative hold). Returns something like {success: true, bookingId, deposit: $X}.
•	We then feed that to model.
•	Bot: responds to user: "I've reserved your party on [date] at 3:00 PM for 10 kids. To confirm the booking, please complete the payment of $X deposit. I've sent the details to your account email as well."
•	Or if slot not available, the function could return an error, and the bot would say "Sorry, that time is unavailable, can you choose a different time?" This conversational approach can greatly enhance UX.
•	Integration in Frontend: We will add a chat UI (maybe an icon bottom-right “Chat with Playfunia Assistant”). Clicking opens a chat window component. The user types questions or requests, and we call our FastAPI /chat endpoint with the message and the conversation context (the frontend can keep the chat history too for display). The assistant’s answer is then displayed with possible links or next suggestions.
•	We ensure the chat UI is always optional and clearly an AI assistant, not a human live chat (to set expectations). The chatbot can help navigate (like a conversational menu: "You can ask me to book parties, find events, or buy tickets.")
•	The chat component should handle streaming responses if we enable streaming (but initial can be non-streaming for simplicity).
•	We also must handle that the chatbot might not always get it right. Provide a way to escalate to human if needed (maybe if user types "agent" or if the AI returns a fallback). The contact_support function covers this scenario by capturing their query for follow-up.
By implementing function calling, the chatbot can perform real actions (booking, etc.) rather than just responding with static info, making it truly useful. The OpenAI cookbook emphasizes that the developer must execute the function and then continue the conversation[59][55], which is exactly our approach.
We will thoroughly test the chatbot with various prompts to ensure it responds accurately and safely (for example, it should not reveal sensitive data – but since we only allow specific functions, it should be fine).
6. Testing and Continuous Integration
To ensure reliability, we will write extensive tests for each part of the system and set up CI to run them on each commit.
Backend Testing (Node/Express)
•	Unit Tests (Jest): Write tests for individual services and utilities:
•	Test the pricing logic functions: e.g., a function calculateTicketPrice(numKids) should return correct bundle prices (1 -> 20, 2 -> 35, 3 -> 50, 4 -> 65, etc.).
•	Test party booking slot conflict logic: ensure that if a booking exists at 10:00–12:00, a new booking at 11:30 is flagged as conflict due to buffer. Also test that 12:30 is allowed (30 min buffer).
•	Test membership usage logic: if Silver allows 5 visits, simulate 5 check-ins and one extra to ensure it blocks the 6th.
•	Test the JWT middleware: give it a valid token and ensure it calls next() with req.userId set, and an invalid token returns 401.
•	Test utility functions like password hashing and verification with bcrypt.
•	Test the admin role middleware: a user token without admin role should be forbidden on admin routes.
•	Integration Tests (Supertest or Jest with server): Spin up the Express app (with an in-memory Mongo like MongoMemoryServer for isolation) and test routes:
•	Auth flow: register a user, login, get token, access a protected endpoint (profile) – expect success. Try accessing without token – expect 401.
•	Waiver submission: POST a waiver for a user with two kids, then verify the children got created in DB and waiver record is there.
•	Ticket purchase: This is tricky to fully test since it involves Stripe. We can mock the Stripe API in tests. For example, stub the call to stripe.paymentIntents.create to return a test client_secret. Then call our /tickets/purchase and assert it returns a client_secret and creates ticket records on webhook. We can simulate a webhook call by calling our webhook handler with a fake event JSON for payment_intent.succeeded. Verify tickets in DB with codes.
•	Membership purchase: Similarly, but maybe simpler to test non-Stripe parts (like DB changes). If using Stripe checkout sessions, skip in unit tests or use Stripe test mode with API keys (not ideal in CI).
•	Booking: Create a booking via API (maybe we skip actual Stripe by faking payment success). Ensure booking saved and cannot double book same slot.
•	Admin endpoints: Using an admin token, try to get user list, bookings, etc. Ensure correct data comes and that a non-admin token is rejected for those routes.
•	Edge cases: test things like invalid inputs (booking a party in the past date, buying 0 tickets, etc.) and ensure proper validation messages (400 errors).
•	Use Jest’s coverage to ensure we hit most critical paths.
Frontend Testing (React)
•	Component Tests (React Testing Library): Focus on critical forms and logic:
•	WaiverForm component: simulate user filling fields and submitting. Mock the fetch API call to backend (using jest-fetch-mock or similar) to return success. Assert that after submission, a success message appears or navigation happens. Also test that required field validation works (e.g., if name is empty and submit, an error message appears).
•	Ticket purchase component: test that selecting different numbers updates the price display correctly. Possibly mock a user context that has or lacks a waiver to see that the waiver warning appears.
•	Party booking component: This one might be complex to fully test with calendar UI. We can test the pricing summary: select some add-ons in state and ensure total price calculation component shows the right sum (including cleaning fee and deposit calculation).
•	Membership page: if toggle monthly/yearly, ensure prices update in the DOM. If user already has membership (simulate context), ensure the UI changes to show status instead of purchase options.
•	Chatbot component: we can mock the /chat API responses. For example, simulate that when user says "What are your membership options?", the component receives a response listing them. Ensure the message appears in the chat window. Also test that conversation history is maintained (send two messages and ensure both show). We might not test actual OpenAI integration here, just that our component handles the loading state and displays the assistant reply.
•	Integration/UI Tests: We can use a tool like Cypress or Playwright for end-to-end testing in a browser environment (perhaps in CI or locally):
•	Signup + book party flow: automated sequence where Cypress clicks through signup, fills booking form, and (maybe we stub Stripe or simply check that clicking checkout opens Stripe without error).
•	Login + buy ticket flow.
•	Admin login + redeem ticket flow: maybe create a ticket via API first, then use UI to redeem it.
•	These E2E tests would ensure the full happy-path works as expected from a user perspective.
Chatbot Service Testing (FastAPI)
•	Unit Tests (Pytest): Test the internal logic of function calling:
•	We can simulate a scenario: provide a user message and pre-defined OpenAI response (monkeypatch the openai.ChatCompletion.create call to return a crafted function_call). Then test our code correctly calls the intended internal function with parsed arguments.
•	For each function, we might mock the backend API call. For example, monkeypatch an internal helper that calls the Express API, instead have it return a sample result (like for get_event_list, return 2 events). Then verify the final assistant message content contains those event details.
•	Test that conversation state is stored and sent appropriately. Perhaps simulate two sequential calls to /chat and ensure the second call included the first messages in the prompt.
•	If possible, test the actual OpenAI integration with very minimal conversation (maybe using gpt-3.5 and a dev key) but that’s not usually done in unit tests due to external dependency and cost. Instead, rely on mocking OpenAI responses.
•	Integration Test: Run the FastAPI app (maybe with TestClient from fastapi) and simulate a full conversation:
•	e.g., send: {"message": "Hi, what events do you have?"}, have OpenAI respond (this requires mocking at HTTP level or using vcrpy to record a real interaction). Check we ultimately get a JSON with an answer listing events.
•	Test a function that requires multi-turn: ask to book party, ensure the assistant asks for details (this means openAI first answer does not have function call but a question). Then user provides detail, next call yields a function call, etc.
•	These can be tricky to test fully deterministically because the AI output could change. By using the function calling with known functions and maybe a fixed temperature or a mock, we can create deterministic outcomes.
Continuous Integration (CI)
•	Use GitHub Actions (or similar CI service) to automate testing:
•	Set up a workflow yaml that installs dependencies for backend, frontend, chatbot.
•	Perhaps split jobs or combine:
o	One job for backend: install Node, run npm ci in backend, start a Mongo test instance (could use services: mongo:latest in GH Actions), run tests (npm run test which invokes Jest).
o	One job for frontend: install Node, run npm ci in frontend, run npm run test -- --watchAll=false for React tests.
o	One job for chatbot: set up Python 3.x, install requirements, run pytest. We might mock OpenAI key in env.
•	Or run them sequentially in one workflow. For efficiency, parallel jobs could be used.
•	Also add an ESLint/Prettier check job: run linter on frontend and backend to catch style issues.
•	Possibly add a build job: build the React app (to ensure no compile errors) and maybe build the Docker images (to ensure Dockerfiles are okay).
•	Configure caching appropriately (like npm/pip caches) to speed up.
•	Trigger: The CI should run on every push and pull request to main branch. If all tests pass, then we can merge or deploy.
•	Deployment (optional): If we were to deploy, we could add jobs to build and push Docker images, etc., but since it's a local app scenario, not needed. However, having the Docker Compose means we could run e2e tests in CI by spinning up the services. That might be overkill here.
•	Coverage and Quality: Aim for high test coverage on critical logic. Possibly use a coverage badge or at least ensure no critical path is untested.
By maintaining this CI pipeline, we ensure that new changes don’t break existing functionality (regressions) and that the entire project remains robust and maintainable.
7. Final QA & Polish
In the last phase, we will thoroughly verify the system against all requirements and refine the user experience:
•	Legal & Data Retention: Double-check the waiver storage procedure. Ensure that waiver records include timestamps and are never deleted within the retention period (5 years)[5]. We will document a data retention policy in the docs/ and possibly implement a backup/export mechanism for waivers (since legal might want periodic backups). Also verify that the waiver export feature works (download file opens correctly).
•	Cleaning Fee Enforcement: Confirm that every party booking calculation automatically adds the \$50 cleaning fee[11]. We test multiple scenarios (with add-ons, without) to see that fee is present exactly once. Also, the UI should clearly show this fee as a separate item so users know why their total increased.
•	Deposit Enforcement: Ensure that the party booking checkout only charges 50% of the total as deposit[11]. For example, if a booking is \$400 total, the Stripe PaymentIntent and charged amount should be \$200. The remaining 50% should not be charged automatically by our system (since we aren't storing cards for later) – instead, our system should mark that \$200 is due on arrival. We’ll update the booking confirmation email to mention the remaining balance. Also, if an admin views the booking, it should show deposit paid and balance outstanding. If we wanted to be thorough, we could allow admin to record the balance payment when it’s made (like a check or card swipe at venue).
•	Sibling Discounts: Re-test the ticket pricing formula to ensure it matches exactly the defined bundles[7]. Specifically, 2 kids should be \$35 (not \$40), 3 kids \$50. If we extended logic beyond 3, ensure that for 4 kids the price makes sense (if no guidance, we used +\$15 per additional child). We’ll state this assumption in documentation to be clear. If the business wanted a cap, we would adjust accordingly.
•	Waiver Before Purchase: Confirm the frontend flow prevents a user from paying without a waiver. For example, try to go to checkout with tickets when waiverSigned=false – it should block and redirect to waiver. Also, if user has a waiver, ensure the system doesn’t nag them again unnecessarily. The admin should also be able to see if a user has a waiver on file easily (maybe in user profile in admin UI).
•	Accessibility Checks: We will add an accessibility toolbar or options:
•	Provide buttons to increase/decrease font size on the site (maybe just a couple of steps, or integrate a JS library to adjust zoom).
•	A toggle for high-contrast mode: perhaps a simple CSS switch (Tailwind can be configured with a dark mode class; we can use that to provide a high-contrast theme, or simply a different stylesheet that meets WCAG contrast guidelines for those who need it).
•	Ensure all images have alt text (especially in Home and events).
•	Ensure forms are navigable by keyboard (tab order, focus states visible).
•	Use ARIA labels for the chat widget icon, etc. These improvements help users with visual impairments or other needs.
•	Localization Support: Though we might not provide full translations due to time, we structure text in a way that could be localized. For instance, store all user-facing strings in a JSON or use a library like i18next. Possibly set up a toggle (even if only English available, we lay groundwork). Document how new languages could be added. Simple example: have a locales/ folder and wrap text output in a translation function. This ensures the app can grow to support multiple languages without a rewrite.
•	Performance and SEO: Not heavily requested, but as polish:
•	Ensure React production build is optimized, and maybe do code-splitting for routes (especially admin vs user).
•	If using Next.js, server-side rendering can help SEO. With CRA, maybe ensure the site has proper meta tags (title, description) and maybe prerender critical info.
•	We may deploy a test instance and perform basic performance audit (Lighthouse).
•	Route Verification: Go through each route (/, /book-party, /waiver, /buy-ticket, /membership, /checkout, /admin, /contact, /events) and confirm the implemented page matches the detailed requirements from the PDF:
•	Home has all sections it should[36][38].
•	Book-party has interactive calendar, add-ons, fees clearly shown[60][61].
•	Waiver page fields are all present[45].
•	Buy-ticket page shows bundle pricing and enforces waiver reminder[7][62].
•	Membership page lists tiers with details and toggle[63].
•	Checkout covers combined items, discounts, waiver check, Stripe integration[49].
•	Admin dashboard covers the listed features (bookings, waivers, tickets, memberships, stats)[51].
•	Contact page has map, contact info, form, FAQ if possible[64].
•	Events page shows calendar of events, details, RSVP links[34]. We will manually test each as if we are an end-user and an admin, checking off all bullet points from the requirements document.
•	Content & UI Polish: Make final adjustments to text content (ensure no placeholder text left, correct grammar and friendly tone). Possibly add small images/icons for clarity (e.g., membership tiers could have medal icons for Silver/Gold). Ensure the color scheme is appealing to children (likely bright primary colors) but also readable.
•	Error Handling & 404s: Ensure that any unknown routes show a friendly 404 page (maybe with a playful graphic, “Oops, kids must have hidden this page!”). Also handle backend errors gracefully on frontend – e.g., if server is down or returns an error, show a message rather than a crash.
•	Security Audit: Double-check that sensitive data is not exposed:
•	JWT tokens are HttpOnly if stored in cookies (we might just keep token in memory or localStorage for simplicity, but HttpOnly cookie is more secure against XSS – consider switching to that).
•	The Express app should not leak stack traces or errors to clients – use a global error handler to send generic error messages.
•	Rate-limit sensitive endpoints (like login) to prevent brute force (could use an express-rate-limit middleware).
•	Ensure the Mongo connection string and secrets are never logged.
•	The chatbot should not inadvertently reveal secrets or perform disallowed actions – but since we constrain its functions, that should be fine.
•	Final Deployment Config: Make sure Docker containers work properly: test docker-compose up on a fresh environment to see all services come up (frontend reachable, backend connecting to Mongo, chatbot reachable). Fix any port or network issues. Possibly adjust container memory or environment for production (e.g., Node using production mode).
•	Documentation: Update README and docs to reflect any changes. Provide instructions for running the system, running tests, seeding data, etc. Include any assumptions (like our sibling pricing formula beyond 3 kids, deposit policy regarding refund). If possible, include screenshots in the docs for clarity.
After these QA steps, the application should meet all the described requirements and provide a smooth experience. We will sign off the project once the stakeholders (or our own verification) are satisfied that every feature is implemented as specified and is working correctly. Each component is modular, well-tested, and maintainable following SOLID principles, setting a strong foundation for future enhancements.
Overall, Playfunia will be a production-quality full-stack application, with a feature-complete implementation and an intelligent chatbot assistant, ready to deliver a delightful experience to both customers and administrators of the indoor playground 🎉.
Sources:
•	StackOverflow discussion on MERN project structure[1] (confirming separate frontend/backend folders and dependencies).
•	Mongoose schema relationships (example of referencing roles in user schema)[4].
•	Playfunia Requirements PDF (detailed page content and features)[60][49].
•	OpenAI Cookbook on function calling (implementation approach for tool use)[52].
•	Stripe documentation on webhooks (asynchronous event handling for payments)[31].
________________________________________
[1] [2] node.js - How to organise file structure of backend and frontend in MERN - Stack Overflow
https://stackoverflow.com/questions/51126472/how-to-organise-file-structure-of-backend-and-frontend-in-mern
[3] MongoDB One-to-Many Relationship tutorial with Mongoose examples - BezKoder
https://www.bezkoder.com/mongoose-one-to-many-relationship/
[4] [13] [14] [15] [16] [17] [18] Node.js + MongoDB: User Authentication & Authorization with JWT - BezKoder
https://www.bezkoder.com/node-js-mongodb-auth-jwt/
[5] [6] [7] [8] [9] [10] [11] [12] [19] [22] [23] [24] [25] [26] [27] [28] [29] [34] [35] [36] [37] [38] [39] [40] [41] [42] [43] [44] [45] [46] [47] [48] [49] [50] [51] [60] [61] [62] [63] [64] Playfunia_Website_Detailed_Pages.pdf
file://file_000000009d9c61f594605fb0a8ade7d0
[20] [21] [30] Stripe Payment Intent Integration - ReactJS and NodeJS | Better Programming
https://medium.com/better-programming/complex-payment-flows-using-stripe-payment-intents-a-reactjs-nodejs-guide-5835f4c004cf
[31] [32] [33] docs.stripe.com
https://docs.stripe.com/webhooks
[52] [53] [54] [55] [56] [57] [58] [59] How to call functions with chat models
https://cookbook.openai.com/examples/how_to_call_functions_with_chat_models
